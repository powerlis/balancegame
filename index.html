<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>📚 밸런스 독서 게임 – 실시간 멀티플레이</title>
  <style>
    /* ====== 첨부 파일의 디스플레이 스타일 계승 ====== */
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

    :root {
      --main-color: #4a044e; /* Deep Purple */
      --light-color: #f3e8ff; /* Light Purple */
      --dark-color: #3b0764;  /* Darker Purple */
      --bg-color: #fdfcff;    /* Off-white */
      --text-dark: #1f2937;
      --text-light: #6b7280;
      --border-color: #e5e7eb;
      --radius: 20px;
    }

    *{ box-sizing:border-box }
    html, body { height: 100% }
    body {
      font-family: 'Noto Sans KR', system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Malgun Gothic, Arial, sans-serif;
      background-color: var(--bg-color);
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }

    /* 전체 앱 컨테이너: 카드 느낌 유지 + 반응형 폭 확장 */
    #app {
      background-color: #fff;
      width: 100%;
      max-width: 920px;           /* 단일·멀티 레이아웃 모두 수용 */
      border-radius: var(--radius);
      box-shadow: 0 10px 25px rgba(0,0,0,0.08);
      overflow: hidden;
    }

    .pad { padding: 24px 22px }
    .head { padding: 26px 22px 10px; text-align: center; }
    .pill {
      display:inline-block;
      background-color: var(--light-color);
      color: var(--main-color);
      font-weight: 700;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
    }
    h1 {
      color: var(--dark-color);
      font-size: clamp(22px, 4.6vw, 32px);
      margin: 10px 0 6px;
    }
    p.lead {
      color: var(--text-light);
      margin: 0 0 8px;
      line-height: 1.6;
    }

    /* 입력/폼 */
    .row{ display:flex; gap:12px; flex-wrap: wrap }
    .col{ flex:1; min-width:260px }
    input[type="text"]{
      width:100%;
      padding:14px 14px;
      border-radius: 14px;
      border:2px solid var(--border-color);
      background:#fff;
      color:var(--text-dark);
      font-size: 1rem;
    }
    input[type="text"]:focus{
      outline:none; border-color: var(--main-color);
      box-shadow: 0 0 0 3px rgba(74,4,78,0.12);
    }

    /* 버튼 (첨부 스타일 유지) */
    .btn {
      display:block;
      width:100%;
      padding:16px;
      margin-top: 10px;
      border:2px solid var(--main-color);
      border-radius: 15px;
      background-color: var(--main-color);
      color:#fff;
      font-size:1.1rem;
      font-weight:700;
      cursor:pointer;
      transition: all .2s ease;
    }
    .btn:hover { background-color: var(--dark-color); border-color: var(--dark-color); transform: translateY(-2px); }
    .btn[disabled]{ opacity:.6; cursor:not-allowed; transform:none }

    /* 옵션 버튼은 흰 배경 + 보라 텍스트(첨부 answer-btn 스타일) */
    .opt {
      background:#fff;
      color:var(--main-color);
      border:2px solid var(--main-color);
      text-align:center;
      padding:16px;
      border-radius: 15px;
      font-weight:700;
      margin-bottom:12px;
      width:100%;
      cursor:pointer;
      transition: all .15s ease;
    }
    .opt:hover { background: var(--light-color); color: var(--dark-color); border-color: var(--dark-color); }
    .opt.selected { outline: 3px solid var(--light-color); }

    /* 카드 */
    .card { border-top: 1px solid var(--border-color); }

    /* 진행 막대 */
    .progress {
      width: 100%; height: 10px; background: var(--border-color); border-radius: 5px; overflow: hidden; margin-bottom: 16px;
    }
    .progress .bar {
      width:0%; height:100%; background: var(--main-color); transition: width .35s ease;
    }

    /* 텍스트 */
    .muted { color: var(--text-light) }
    .tag {
      display:inline-block;
      border:1px solid var(--border-color);
      padding:6px 10px;
      border-radius:999px;
      background:#f9fafb;
      margin:4px 6px 0 0;
      font-size: .95rem;
    }

    /* 표 (결과용) */
    table { width:100%; border-collapse: collapse }
    th, td { border:1px solid var(--border-color); padding:8px 10px; text-align: center }
    th { background:#f8fafc }

    /* 배너/경고 */
    .banner { width:100%; max-width:920px; margin: 10px auto 0; }
    .error {
      background:#fef2f2; border:1px solid #fecaca; color:#991b1b;
      padding:10px 12px; border-radius: 12px; margin-bottom: 12px; white-space: pre-wrap;
    }

    /* 페이지 전환 애니메이션 느낌 */
    .fadeIn { animation: fadeIn .35s ease }
    @keyframes fadeIn { from{opacity:0; transform: translateY(8px)} to{opacity:1; transform:none} }
  </style>
</head>
<body>
  <div class="banner" id="banner"></div>

  <div id="app" class="fadeIn">
    <!-- JS 렌더 -->
  </div>

  <!-- Firebase SDK (CDN/compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>

  <script>
  /* ======================= 상태/유틸 ======================= */
  const appEl = document.getElementById('app');
  const banner = document.getElementById('banner');
  const $ = (s,c=document)=>c.querySelector(s);
  const uid = ()=>'P'+Math.random().toString(36).slice(2,8).toUpperCase();
  const code6 = ()=>Math.random().toString(36).toUpperCase().replace(/[^A-Z0-9]/g,'').slice(2,8);

  let me = { id:null, name:'', role:'player' };
  let room = { id:null, secret:null };
  let db = null, firebaseReady = false;

  let unsubRoom = null, unsubPlayers = null, unsubAnswers = null;
  let subscribedIndex = null;

  let latestRoomData = null;
  let latestPlayers = [];
  let curIndex = 0;

  /* ======================= 질문(2선택 밸런스 10문항) ======================= */
  const QUESTIONS = [
    { id:'Q1', title:'책갈피가 없을 때?', options:[
      { text:'a. 책 모서리 접으면 간단하지', type:'A' },
      { text:'b. 새 책 느낌 지켜! 절대 접지 않는다', type:'B' }
    ]},
    { id:'Q2', title:'읽었던 책을 다시 볼 기회가 있다면?', options:[
      { text:'a. 새로운 느낌으로 다시 읽으면 재밌겠다.', type:'A' },
      { text:'b. 한번 본 책을 왜 또 봄?', type:'B' }
    ]},
    { id:'Q3', title:'책 읽는 중간에 방해받으면?', options:[
      { text:'a. 뭐 어때, 신경 끄고 이어서 읽으면 되지', type:'A' },
      { text:'b. 아, 지금은 읽을 타이밍이 아닌가? 다음에 읽어야지.', type:'B' }
    ]},
    { id:'Q4', title:'명대사를 발견하면?', options:[
      { text:'a. 이건 인생 문장! 인덱스 붙이고 기록해야지', type:'A' },
      { text:'b. 음.. 좋네...(그냥 마음에만 담아둔다)', type:'B' }
    ]},
    { id:'Q5', title:'클라이맥스에서 잠이 올 때?', options:[
      { text:'a. 졸리면 그냥 잔다 (독서=수면제)', type:'A' },
      { text:'b. 이야기 흐름 지켜! 끝까지 버틴다', type:'B' }
    ]},
    { id:'Q6', title:'책을 고를 때 나는?', options:[
      { text:'a. 감으로 고른다 (표지, 제목, 느낌!)', type:'A' },
      { text:'b. 리뷰/추천을 꼼꼼히 보고 고른다', type:'B' }
    ]},
    { id:'Q7', title:'책에 물이나 얼룩이 묻었다면?', options:[
      { text:'a. 마음의 상처, 새로 사고 싶다', type:'A' },
      { text:'b. 추억의 흔적이라 생각한다', type:'B' }
    ]},
    { id:'Q8', title:'나는 내 책에 이름을...', options:[
      { text:'a. 꼭 적는다(내 소중한 책이니까)', type:'A' },
      { text:'b. 절대 안 적는다(깨끗해야해!)', type:'B' }
    ]},
    { id:'Q9', title:'등장인물이 너무 많다면?', options:[
      { text:'a. 메모하거나 표시해둔다', type:'A' },
      { text:'b. 그냥 감으로 기억한다', type:'B' }
    ]},
    { id:'Q10', title:'친구가 내게 책을 빌려달라 하면?', options:[
      { text:'a. 같이 읽자! 기꺼이 빌려준다', type:'A' },
      { text:'b. 책 헤지면 속상해… 살짝 망설인다', type:'B' }
    ]}
  ];

  /* ======================= 시작 화면 ======================= */
  function renderStart(){
    appEl.innerHTML = `
      <div class="head">
        <span class="pill">휴대폰 참여 · 실시간</span>
        <h1>밸런스 독서 게임</h1>
        <p class="lead">호스트는 방을 만들고, 참가자는 방 코드로 입장합니다.</p>
      </div>
      <div class="pad card">
        <div class="row">
          <div class="col">
            <label class="muted" for="hostName">호스트 이름</label>
            <input id="hostName" type="text" placeholder="예: 사회자/교사" />
            <button class="btn" id="mkroom">방 만들기</button>
          </div>
          <div class="col">
            <label class="muted" for="code">방 코드 & 참가자 이름</label>
            <input id="code" type="text" placeholder="방 코드(예: ABC123)" />
            <input id="name" type="text" placeholder="내 이름(참가자)" style="margin-top:10px" />
            <button class="btn" id="join">참가자로 입장</button>
          </div>
        </div>
        <p class="muted" style="margin:14px 4px 0">Firestore 상태: <b>${firebaseReady?'연결됨':'미연결(콘솔/규칙 확인)'}</b></p>
      </div>
    `;

    $('#mkroom').addEventListener('click', async ()=>{
      if(!firebaseReady) return showErr('Firebase가 아직 연결되지 않았어요. 프로젝트/규칙을 확인해 주세요.');
      const name = $('#hostName').value.trim() || 'Host';
      try { await createRoom(name); } catch(e){ showErr('방 만들기 실패: '+(e?.message||e)); }
    });

    $('#join').addEventListener('click', async ()=>{
      if(!firebaseReady) return showErr('Firebase가 아직 연결되지 않았어요. 프로젝트/규칙을 확인해 주세요.');
      const code = $('#code').value.trim().toUpperCase();
      const name = $('#name').value.trim() || '참가자';
      if(!code) return showErr('방 코드를 입력해 주세요.');
      try { await joinRoom(code, name); } catch(e){ showErr('입장 실패: '+(e?.message||e)); }
    });
  }

  function showErr(msg){
    banner.innerHTML = `<div class="error">⚠️ ${msg}</div>`;
    console.error(msg);
  }

  /* ======================= Firebase 연결 ======================= */
  (function connectFirebase(){
    try{
      const cfg = {
        apiKey: "AIzaSyApSfouaSStrJ7YKjjU-V3YByqO0cd_AIc",
        authDomain: "balancegame-43c9b.firebaseapp.com",
        projectId: "balancegame-43c9b",
        storageBucket: "balancegame-43c9b.appspot.com",
        messagingSenderId: "334047765801",
        appId: "1:334047765801:web:50a37aa30ed5b0f06bc338",
        measurementId: "G-GEWHJK9SP3"
      };
      if(!(window.firebase && firebase.initializeApp)){
        showErr("Firebase SDK가 로드되지 않았습니다. (네트워크/CSP 차단 가능)");
        renderStart(); return;
      }
      firebase.initializeApp(cfg);
      db = firebase.firestore();
      firebaseReady = true;

      // 접근 확인용(권한 없으면 에러 노출)
      db.collection("_ping").limit(1).get()
        .then(()=>renderStart())
        .catch(e=>{ showErr("Firestore 접근 실패: 콘솔 규칙을 Publish 했는지 확인해 주세요.\n"+(e?.message||e)); renderStart(); });
    }catch(e){
      showErr("Firebase 초기화 오류: "+(e?.message||e));
      renderStart();
    }
  })();

  /* ======================= Firestore I/O ======================= */
  async function createRoom(hostName){
    const id = code6();
    const secret = Math.random().toString(36).slice(2,10);
    await db.collection('rooms').doc(id).set({
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      currentIndex: -1,
      started: false,
      hostId: null,
      secret,
    });
    room.id = id; room.secret = secret;
    me = { id: uid(), name: hostName, role:'host' };
    await db.collection('rooms').doc(id).collection('players').doc(me.id).set({
      name: me.name, role:'host',
      joinedAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    await db.collection('rooms').doc(id).update({ hostId: me.id });
    listenRoom();
  }

  async function joinRoom(code, name){
    const snap = await db.collection('rooms').doc(code).get();
    if(!snap.exists){ showErr('존재하지 않는 방 코드입니다.'); return; }
    room.id = code; room.secret = snap.data().secret || null;
    me = { id: uid(), name, role:'player' };
    await db.collection('rooms').doc(code).collection('players').doc(me.id).set({
      name: me.name, role:'player',
      joinedAt: firebase.firestore.FieldValue.serverTimestamp()
    });
    listenRoom();
  }

  function listenRoom(){
    if (unsubRoom) unsubRoom();
    unsubRoom = db.collection('rooms').doc(room.id).onSnapshot(doc=>{
      if(!doc.exists){ showErr('방이 종료되었습니다.'); renderStart(); return; }
      latestRoomData = doc.data();
      renderGame(latestRoomData, latestPlayers);
    });

    if (unsubPlayers) unsubPlayers();
    unsubPlayers = db.collection('rooms').doc(room.id).collection('players')
      .orderBy('joinedAt','asc')
      .onSnapshot(snap=>{
        latestPlayers = snap.docs.map(d=>({ id:d.id, ...d.data() }));
        if(latestRoomData) renderGame(latestRoomData, latestPlayers);
      });
  }

  async function answersFor(index){
    const qs = await db.collection('rooms').doc(room.id).collection('answers').where('qIndex','==',index).get();
    return qs.docs.map(d=>d.data());
  }

  async function startGame(){
    await db.collection('rooms').doc(room.id).update({ started:true, currentIndex:0 });
  }

  async function nextQuestionSafe(cur){
    const ref = db.collection('rooms').doc(room.id);
    await db.runTransaction(async tx=>{
      const snap = await tx.get(ref);
      if(!snap.exists) throw new Error('room not found');
      const now = snap.data().currentIndex ?? -1;
      if(now===cur){
        tx.update(ref, { currentIndex: Math.min(cur+1, QUESTIONS.length) });
      }
    });
  }

  async function pick(index, type){
    const docId = `${me.id}_${index}`;
    return db.collection('rooms').doc(room.id).collection('answers').doc(docId).set({
      playerId: me.id, name: me.name, qIndex: index, type,
      at: firebase.firestore.FieldValue.serverTimestamp(),
    }, { merge:true });
  }

  /* ======================= 화면 렌더 ======================= */
  async function renderGame(roomDoc, players){
    const cur = roomDoc.currentIndex;
    curIndex = cur;

    // 현재 문항 answers 실시간 구독(전원 응답 감지)
    if (cur >= 0 && cur < QUESTIONS.length) {
      if (subscribedIndex !== cur) {
        if (unsubAnswers) { unsubAnswers(); unsubAnswers = null; }
        subscribedIndex = cur;
        unsubAnswers = db.collection('rooms').doc(room.id)
          .collection('answers').where('qIndex','==',cur)
          .onSnapshot(()=>{ if(latestRoomData) renderGame(latestRoomData, latestPlayers); });
      }
    } else {
      if (unsubAnswers) { unsubAnswers(); unsubAnswers = null; }
      subscribedIndex = null;
    }

    const head = `
      <div class="head">
        <span class="pill">방 코드 ${room.id||'-'}</span>
        <h1>밸런스 독서 게임</h1>
        <p class="lead">${players.length}명 참여 중</p>
      </div>
    `;

    // 대기실
    if(cur < 0 || !roomDoc.started){
      appEl.innerHTML = `
        ${head}
        <div class="pad card">
          <h3 style="margin:0 0 6px">대기실</h3>
          <p class="muted">링크를 공유하고 <b>방 코드</b>로 입장하세요.</p>
          <div style="margin:10px 0 6px">
            ${players.length ? players.map(p=>`<span class="tag">${p.name}${p.role==='host'?' (호스트)':''}</span>`).join(' ') : '<span class="muted">아직 참가자 없음</span>'}
          </div>
          ${me.role==='host' ? '<button class="btn" id="start">게임 시작</button>' : ''}
        </div>
      `;
      if(me.role==='host') $('#start').addEventListener('click', startGame);
      return;
    }

    // 결과 화면
    if(cur >= QUESTIONS.length){
      const allAnsSnap = await db.collection('rooms').doc(room.id).collection('answers').get();
      const answers = allAnsSnap.docs.map(d=>d.data());
      const qCount = QUESTIONS.length;

      // 두 참가자 간 매칭된 문제 목록
      function pairMatches(aId, bId){
        const list=[];
        for(let i=0;i<qCount;i++){
          const Pa = answers.find(x=>x.playerId===aId && x.qIndex===i);
          const Pb = answers.find(x=>x.playerId===bId && x.qIndex===i);
          if(Pa && Pb && Pa.type===Pb.type){
            const optType = Pa.type;
            const optText = QUESTIONS[i].options.find(o=>o.type===optType)?.text || (optType==='A'?'a.':'b.');
            list.push({ index:i, title: QUESTIONS[i].title, type: optType, text: optText });
          }
        }
        return list;
      }
      function matchMessage(n){
        if(n<=2) return { title:'책은 같이 읽지만... 마음은 평행선 💫', desc:'완전 반대 취향이지만 그래서 더 재밌어요! 대화할 거리 가득한 조합.' };
        if(n<=5) return { title:'다르지만 묘하게 통하는 독서 친구 📖', desc:'관점은 달라도 서로 존중하는 이상적인 듀오.' };
        if(n<=8) return { title:'같이 힐링하는 찐독서메이트 🌿', desc:'읽는 습관/취향이 비슷! 서가에서도 자주 마주치는 타입.' };
        return { title:'독서 소울메이트 발견! 💞', desc:'책 속에서도 만날 운명! 취향 싱크가 완벽합니다.' };
      }

      // 전체 매칭 표
      const playersNow = players;
      let table = '<table><thead><tr><th>상대</th>';
      playersNow.forEach(p=> table += `<th>${p.name}</th>`);
      table += '</tr></thead><tbody>';
      playersNow.forEach(r=>{
        table += `<tr><th>${r.name}</th>`;
        playersNow.forEach(c=>{
          if(r.id===c.id) table += '<td>—</td>';
          else {
            const s = pairMatches(r.id,c.id).length;
            const rate = Math.round((s/qCount)*100);
            table += `<td>${s}/${qCount} (${rate}%)</td>`;
          }
        });
        table += '</tr>';
      });
      table += '</tbody></table>';

      // 페어 카드(매칭된 문제 + A/B 보기까지)
      let pairCards = '';
      if(playersNow.length>=2){
        for(let i=0;i<playersNow.length;i++){
          for(let j=i+1;j<playersNow.length;j++){
            const A = playersNow[i], B = playersNow[j];
            const matches = pairMatches(A.id,B.id);
            const msg = matchMessage(matches.length);
            const listHTML = matches.length
              ? `<ol style="margin:.4rem 0 0 1.2rem;padding:0">
                    ${matches.map(x=>`
                      <li style="margin:.2rem 0">
                        <b>Q${x.index+1}.</b> ${x.title}<br/>
                        <span class="tag">공통 선택: ${x.type}</span>
                        <span class="tag">${x.text}</span>
                      </li>`).join('')}
                 </ol>`
              : `<p class="muted" style="margin:.4rem 0 0">매칭된 문제가 없습니다.</p>`;
            pairCards += `
              <div class="pad card" style="margin-top:12px; border-radius:${'calc(var(--radius) - 6px)'}">
                <span class="pill">${A.name} × ${B.name}</span>
                <h3 style="margin:.6rem 0 0">일치 ${matches.length}/${qCount}</h3>
                <p class="muted" style="margin:.2rem 0 .4rem">${msg.title}</p>
                <p>${msg.desc}</p>
                <div class="pad" style="background:#f9fafb; border:1px solid var(--border-color); border-radius:14px; margin-top:8px">
                  <h4 style="margin:.2rem 0 .4rem">매칭된 문제 목록</h4>
                  ${listHTML}
                </div>
              </div>
            `;
          }
        }
      }

      appEl.innerHTML = `
        ${head}
        <div class="pad card">
          <h3 style="margin:0 0 10px">취향 겹침(같은 타입 선택 비율)</h3>
          ${table}
          ${pairCards ? `<div class="pad card" style="margin-top:14px"><h3 style="margin:0 0 8px">페어 매칭 상세</h3>${pairCards}</div>`:''}
          <button class="btn" id="restart" style="margin-top:14px">다시 하기(새 방)</button>
        </div>
      `;
      $('#restart').addEventListener('click', ()=>location.reload());
      return;
    }

    // 진행 화면 (실시간 집계/사이드 제거)
    const q = QUESTIONS[cur];
    const picks = await answersFor(cur);
    const myPick = picks.find(a=>a.playerId===me.id)?.type || null;

    // 전원 응답 확인
    const answeredIds = new Set(picks.map(p=>p.playerId));
    const allAnswered = players.every(p=>answeredIds.has(p.id));

    appEl.innerHTML = `
      ${head}
      <div class="pad card">
        <div class="progress"><div class="bar" style="width:${Math.round((cur/QUESTIONS.length)*100)}%"></div></div>
        <div class="muted" style="margin-bottom:6px">문항 ${cur+1} / ${QUESTIONS.length}</div>
        <h2 style="color:var(--text-dark); font-size:1.35rem; margin: 0 0 14px">${q.title}</h2>

        ${q.options.map(o=>`
          <button type="button" class="opt ${myPick===o.type?'selected':''}" data-type="${o.type}">
            ${o.text}
          </button>
        `).join('')}

        <p class="muted" style="margin:10px 0 0">선택을 완료하면 호스트가 다음 문항으로 진행합니다.</p>

        ${ me.role==='host'
            ? `<button class="btn" id="nextHost" ${!allAnswered?'disabled title="모두 응답해야 진행 가능"':''} style="margin-top:12px">다음(호스트)</button>`
            : '' }
      </div>
    `;

    // 호스트만 진행 버튼
    const btnHost = $('#nextHost');
    if(btnHost){
      btnHost.addEventListener('click', ()=>{
        if(allAnswered) nextQuestionSafe(cur);
      });
    }
  }

  // 옵션 버튼(동적) — 이벤트 위임
  if(!window.__optDelegated){
    appEl.addEventListener('click', async (e)=>{
      const btn = e.target.closest('.opt');
      if(!btn) return;

      // 표시
      appEl.querySelectorAll('.opt').forEach(b=>b.classList.remove('selected'));
      btn.classList.add('selected');

      if(!firebaseReady || !db) { alert(`(테스트) ${btn.textContent} 선택`); return; }

      try{
        await pick(curIndex, btn.dataset.type);
        // onSnapshot으로 자동 리렌더
      }catch(err){
        showErr('선택 저장 실패: ' + (err?.message||err));
      }
    });
    window.__optDelegated = true;
  }

  // 초기 렌더
  renderStart();

  // 전역 에러
  window.addEventListener('error', e=>{ showErr("스크립트 오류: " + (e?.message||e)); });
  </script>

  <!-- ▼ Firestore 규칙(테스트용 예시) – 콘솔 > Firestore Database > Rules에서 Publish
  // 데모/테스트에서만 사용하세요. 운영 전에는 인증/제한을 반드시 적용하세요.
  rules_version = '2';
  service cloud.firestore {
    match /databases/{database}/documents {
      match /{document=**} { allow read, write: if true; }
    }
  }
  ▲ -->
</body>
</html>
